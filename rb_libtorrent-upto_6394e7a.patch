--- a/bindings/python/Jamfile	2018-04-09 14:04:33.000000000 +0700
+++ b/bindings/python/Jamfile	2018-04-25 10:16:54.000000000 +0700
@@ -1,4 +1,5 @@
 import python ;
+import feature ;
 import feature : feature ;
 import project ;
 import targets ;
@@ -27,11 +28,33 @@
 	using python : : "$(LIBTORRENT_PYTHON_INTERPRETER)" : : : <libtorrent-python>on ;
 }

+# copied from boost 1.63's boost python jamfile
+rule find-py3-version
+{
+    local versions = [ feature.values python ] ;
+    local py3ver ;
+    for local v in $(versions)
+    {
+        if $(v) >= 3.0
+        {
+            py3ver = $(v) ;
+        }
+    }
+    return $(py3ver) ;
+}
+
 if $(BOOST_ROOT)
 {
 	use-project /boost : $(BOOST_ROOT) ;
 	alias boost_python : /boost/python//boost_python : : : <include>$(BOOST_ROOT) ;
-	alias boost_python3 : /boost/python//boost_python3 : : : <include>$(BOOST_ROOT) ;
+	if [ find-py3-version ]
+	{
+		alias boost_python3 : /boost/python//boost_python3 : : : <include>$(BOOST_ROOT) ;
+	}
+	else
+	{
+		alias boost_python3 ;
+	}
 }
 else
 {
@@ -50,7 +73,7 @@
 	;

 	# the names are decorated in MacPorts
-	lib boost_python : : <target-os>darwin <name>boost_python-mt
+	lib boost_python : : <target-os>darwin <name>boost_python27-mt
 		: : $(boost-include-path) ;
 	lib boost_python3 : : <target-os>darwin <name>boost_python3-mt
 		: : $(boost-include-path) ;
--- a/docs/manual-ref.rst
+++ b/docs/manual-ref.rst
@@ -458,6 +458,15 @@
 | ``num_downloaders``      | integer. An estimate of the number of downloaders on this    |
 |                          | torrent when the resume data was last saved. This is used as |
 |                          | an initial estimate until we acquire up-to-date scrape info. |
++--------------------------+--------------------------------------------------------------+
+| ``last_upload``          | integer. The number of seconds since epoch when we last      |
+|                          | uploaded payload to a peer on this torrent.                  |
++--------------------------+--------------------------------------------------------------+
+| ``last_download``        | integer. The number of seconds since epoch when we last      |
+|                          | downloaded payload from a peer on this torrent.              |
++--------------------------+--------------------------------------------------------------+
+| ``last_scrape``          | integer. The number of seconds since epoch when we last sent |
+|                          | a scrape request to a tracker on this torrent.               |
 +--------------------------+--------------------------------------------------------------+
 | ``upload_rate_limit``    | integer. In case this torrent has a per-torrent upload rate  |
 |                          | limit, this is that limit. In bytes per second.              |
--- a/docs/manual-ref.html
+++ b/docs/manual-ref.html
@@ -471,6 +471,18 @@
 torrent when the resume data was last saved. This is used as
 an initial estimate until we acquire up-to-date scrape info.</td>
 </tr>
+<tr><td><tt class="docutils literal">last_upload</tt></td>
+<td>integer. The number of seconds since epoch when we last
+uploaded payload to a peer on this torrent.</td>
+</tr>
+<tr><td><tt class="docutils literal">last_download</tt></td>
+<td>integer. The number of seconds since epoch when we last
+downloaded payload from a peer on this torrent.</td>
+</tr>
+<tr><td><tt class="docutils literal">last_scrape</tt></td>
+<td>integer. The number of seconds since epoch when we last sent
+a scrape request to a tracker on this torrent.</td>
+</tr>
 <tr><td><tt class="docutils literal">upload_rate_limit</tt></td>
 <td>integer. In case this torrent has a per-torrent upload rate
 limit, this is that limit. In bytes per second.</td>
--- a/include/libtorrent/aux_/session_interface.hpp	2018-04-09 14:04:33.000000000 +0700
+++ b/include/libtorrent/aux_/session_interface.hpp	2018-04-25 10:16:54.000000000 +0700
@@ -52,6 +52,7 @@

 #ifndef TORRENT_DISABLE_LOGGING
 #include <boost/shared_ptr.hpp>
+#include <cstdarg> // for va_list
 #endif

 #ifdef TORRENT_USE_OPENSSL
--- a/include/libtorrent/bencode.hpp	2018-04-09 14:04:33.000000000 +0700
+++ b/include/libtorrent/bencode.hpp	2018-04-25 10:16:54.000000000 +0700
@@ -212,7 +212,7 @@
 				break;
 			case entry::preformatted_t:
 				std::copy(e.preformatted().begin(), e.preformatted().end(), out);
-				ret += e.preformatted().size();
+				ret += static_cast<int>(e.preformatted().size());
 				break;
 			case entry::undefined_t:

--- a/include/libtorrent/ip_filter.hpp	2018-04-09 14:04:33.000000000 +0700
+++ b/include/libtorrent/ip_filter.hpp	2018-04-25 10:16:54.000000000 +0700
@@ -41,10 +41,16 @@
 #include <vector>

 #include <boost/limits.hpp>
-#include <boost/utility.hpp>
 #include <boost/cstdint.hpp>
 #include <boost/tuple/tuple.hpp>

+#include <boost/version.hpp>
+#if BOOST_VERSION >= 106700
+#include <boost/next_prior.hpp>
+#else
+#include <boost/utility.hpp>
+#endif
+
 #include "libtorrent/aux_/disable_warnings_pop.hpp"

 #include "libtorrent/address.hpp"
--- a/include/libtorrent/torrent.hpp	2018-04-09 14:04:33.000000000 +0700
+++ b/include/libtorrent/torrent.hpp	2018-04-25 10:16:54.000000000 +0700
@@ -735,11 +735,7 @@
 		void scrape_tracker(int idx, bool user_triggered);
 		void announce_with_tracker(boost::uint8_t e
 			= tracker_request::none);
-		int seconds_since_last_scrape() const
-		{
-			return m_last_scrape == (std::numeric_limits<boost::int16_t>::min)()
-				? -1 : int(m_ses.session_time() - m_last_scrape);
-		}
+		int seconds_since_last_scrape() const;

 #ifndef TORRENT_DISABLE_DHT
 		void dht_announce();
@@ -1089,7 +1085,8 @@
 		// that are not private
 		void lsd_announce();

-		void update_last_upload() { m_last_upload = m_ses.session_time(); }
+		void update_last_upload()
+		{ m_last_upload = total_seconds(clock_type::now().time_since_epoch()); }

 		void set_apply_ip_filter(bool b);
 		bool apply_ip_filter() const { return m_apply_ip_filter; }
@@ -1654,9 +1651,8 @@
 // ----

 		// the timestamp of the last piece passed for this torrent specified in
-		// session_time. This is signed because it must be able to represent time
-		// before the session started
-		boost::int16_t m_last_download;
+		// seconds since epoch.
+		boost::uint32_t m_last_download;

 		// the number of peer connections to seeds. This should be the same as
 		// counting the peer connections that say true for is_seed()
@@ -1667,9 +1663,8 @@
 		boost::uint16_t m_num_connecting_seeds;

 		// the timestamp of the last byte uploaded from this torrent specified in
-		// session_time. This is signed because it must be able to represent time
-		// before the session started.
-		boost::int16_t m_last_upload;
+		// seconds since epoch.
+		boost::uint32_t m_last_upload;

 		// this is a second count-down to when we should tick the
 		// storage for this torrent. Ticking the storage is used
@@ -1709,7 +1704,7 @@
 		// the timestamp of the last scrape request to one of the trackers in
 		// this torrent specified in session_time. This is signed because it must
 		// be able to represent time before the session started
-		boost::int16_t m_last_scrape;
+		boost::uint32_t m_last_scrape;

 // ----

--- a/src/assert.cpp	2018-04-09 14:04:33.000000000 +0700
+++ b/src/assert.cpp	2018-04-25 10:16:54.000000000 +0700
@@ -352,10 +352,14 @@

 	// if production asserts are defined, don't abort, just print the error
 #ifndef TORRENT_PRODUCTION_ASSERTS
+	#ifdef _MSC_VER
+	__debugbreak();
+	#else
 	// send SIGINT to the current process
 	// to break into the debugger
 	raise(SIGABRT);
 	abort();
+	#endif
 #endif
 }

--- a/src/disk_io_thread.cpp	2018-04-09 14:04:33.000000000 +0700
+++ b/src/disk_io_thread.cpp	2018-04-25 10:16:54.000000000 +0700
@@ -62,6 +62,7 @@
 #if __cplusplus >= 201103L || defined __clang__

 #if DEBUG_DISK_THREAD
+#include <cstdarg> // for va_list
 #define DLOG(...) debug_log(__VA_ARGS__)
 #else
 #define DLOG(...) do {} while(false)
--- a/src/kademlia/dht_tracker.cpp	2018-04-09 14:04:33.000000000 +0700
+++ b/src/kademlia/dht_tracker.cpp	2018-04-25 10:16:54.000000000 +0700
@@ -224,7 +224,10 @@
 	void dht_tracker::get_peers(sha1_hash const& ih
 		, boost::function<void(std::vector<tcp::endpoint> const&)> f)
 	{
-		m_dht.get_peers(ih, f, NULL, false);
+		// TODO: Use `{}` instead of spelling out the whole function type when this is merged to master
+		m_dht.get_peers(ih, f
+			, boost::function<void(std::vector<std::pair<node_entry, std::string> > const&)>()
+			, false);
 	}

 	void dht_tracker::announce(sha1_hash const& ih, int listen_port, int flags
--- a/src/kademlia/routing_table.cpp	2018-04-09 14:04:33.000000000 +0700
+++ b/src/kademlia/routing_table.cpp	2018-04-25 10:16:54.000000000 +0700
@@ -54,6 +54,13 @@
 #include <boost/cstdint.hpp>
 #include <boost/bind.hpp>

+#include <boost/version.hpp>
+#if BOOST_VERSION >= 106700
+#include <boost/next_prior.hpp>
+#else
+#include <boost/utility.hpp>
+#endif
+
 #include "libtorrent/aux_/disable_warnings_pop.hpp"

 using boost::uint8_t;
--- a/src/session_impl.cpp	2018-04-09 14:04:33.000000000 +0700
+++ b/src/session_impl.cpp	2018-04-25 10:16:54.000000000 +0700
@@ -107,6 +107,8 @@
 // for logging stat layout
 #include "libtorrent/stat.hpp"

+#include <cstdarg> // for va_list
+
 // for logging the size of DHT structures
 #ifndef TORRENT_DISABLE_DHT
 #include <libtorrent/kademlia/find_data.hpp>
--- a/src/storage.cpp	2018-04-09 14:04:33.000000000 +0700
+++ b/src/storage.cpp	2018-04-25 10:16:54.000000000 +0700
@@ -1792,19 +1792,10 @@

 	int piece_manager::check_no_fastresume(storage_error& ec)
 	{
-		bool has_files = false;
 		if (!m_storage->settings().get_bool(settings_pack::no_recheck_incomplete_resume))
 		{
 			storage_error se;
-			has_files = m_storage->has_any_file(se);
-
-			if (se)
-			{
-				ec = se;
-				return fatal_disk_error;
-			}
-
-			if (has_files)
+			if (m_storage->has_any_file(se))
 			{
 				// always initialize the storage
 				int ret = check_init_storage(ec);
--- a/src/torrent.cpp	2018-04-09 14:04:33.000000000 +0700
+++ b/src/torrent.cpp	2018-04-25 10:16:54.000000000 +0700
@@ -115,6 +115,8 @@
 {
 	namespace {

+	boost::uint32_t const unset = std::numeric_limits<boost::uint32_t>::max();
+
 	bool is_downloading_state(int st)
 	{
 		switch (st)
@@ -302,17 +304,17 @@
 		, m_deleted(false)
 		, m_pinned((p.flags & add_torrent_params::flag_pinned) != 0)
 		, m_should_be_loaded(true)
-		, m_last_download((std::numeric_limits<boost::int16_t>::min)())
+		, m_last_download(unset)
 		, m_num_seeds(0)
 		, m_num_connecting_seeds(0)
-		, m_last_upload((std::numeric_limits<boost::int16_t>::min)())
+		, m_last_upload(unset)
 		, m_storage_tick(0)
 		, m_auto_managed(p.flags & add_torrent_params::flag_auto_managed)
 		, m_current_gauge_state(no_gauge_state)
 		, m_moving_storage(false)
 		, m_inactive(false)
 		, m_downloaded(0xffffff)
-		, m_last_scrape((std::numeric_limits<boost::int16_t>::min)())
+		, m_last_scrape(unset)
 		, m_progress_ppm(0)
 		, m_pending_active_change(false)
 		, m_use_resume_save_path((p.flags & add_torrent_params::flag_use_resume_save_path) != 0)
@@ -3393,10 +3395,16 @@
 		update_tracker_timer(now);
 	}

+	int torrent::seconds_since_last_scrape() const
+	{
+		return m_last_scrape == unset ? -1
+		: total_seconds(clock_type::now() - time_point(seconds(m_last_scrape)));
+	}
+
 	void torrent::scrape_tracker(int idx, bool user_triggered)
 	{
 		TORRENT_ASSERT(is_single_thread());
-		m_last_scrape = m_ses.session_time();
+		m_last_scrape = total_seconds(clock_type::now().time_since_epoch());

 		if (m_trackers.empty()) return;

@@ -3555,7 +3563,7 @@
 		update_tracker_timer(now);

 		if (resp.complete >= 0 && resp.incomplete >= 0)
-			m_last_scrape = m_ses.session_time();
+			m_last_scrape = total_seconds(clock_type::now().time_since_epoch());

 #ifndef TORRENT_DISABLE_LOGGING
 		std::string resolved_to;
@@ -4403,7 +4411,7 @@
 				// is deallocated by the torrent once it starts seeding
 			}

-			m_last_download = m_ses.session_time();
+			m_last_download = total_seconds(clock_type::now().time_since_epoch());

 			if (m_share_mode)
 				recalc_share_mode();
@@ -7027,13 +7035,12 @@
 #endif
 		}

-		int now = m_ses.session_time();
-		int tmp = rd.dict_find_int_value("last_scrape", -1);
-		m_last_scrape = tmp == -1 ? (std::numeric_limits<boost::int16_t>::min)() : now - tmp;
+		boost::int64_t tmp = rd.dict_find_int_value("last_scrape", -1);
+		m_last_scrape = tmp == -1 ? unset : tmp;
 		tmp = rd.dict_find_int_value("last_download", -1);
-		m_last_download = tmp == -1 ? (std::numeric_limits<boost::int16_t>::min)() : now - tmp;
+		m_last_download = tmp == -1 ? unset : tmp;
 		tmp = rd.dict_find_int_value("last_upload", -1);
-		m_last_upload = tmp == -1 ? (std::numeric_limits<boost::int16_t>::min)() : now - tmp;
+		m_last_upload = tmp == -1 ? unset : tmp;

 		if (m_use_resume_save_path)
 		{
@@ -7275,6 +7282,9 @@
 		ret["num_complete"] = m_complete;
 		ret["num_incomplete"] = m_incomplete;
 		ret["num_downloaded"] = m_downloaded;
+		ret["last_upload"] = m_last_upload == unset ? -1 : boost::int64_t(m_last_upload);
+		ret["last_download"] = m_last_download == unset ? -1 : boost::int64_t(m_last_download);
+		ret["last_scrape"] = m_last_scrape == unset ? -1 : boost::int64_t(m_last_scrape);

 		ret["sequential_download"] = m_sequential_download;

@@ -9613,13 +9623,6 @@
 		return a - b;
 	}

-	int clamped_subtract_s16(int a, int b)
-	{
-		if (a + (std::numeric_limits<boost::int16_t>::min)() < b)
-			return (std::numeric_limits<boost::int16_t>::min)();
-		return a - b;
-	}
-
 	} // anonymous namespace

 	// this is called every time the session timer takes a step back. Since the
@@ -9674,10 +9677,6 @@
 		}
 		m_became_finished = clamped_subtract(m_became_finished, seconds);

-		m_last_upload = clamped_subtract_s16(m_last_upload, seconds);
-		m_last_download = clamped_subtract_s16(m_last_download, seconds);
-		m_last_scrape = clamped_subtract_s16(m_last_scrape, seconds);
-
 		m_last_saved_resume = clamped_subtract(m_last_saved_resume, seconds);
 		m_upload_mode_time = clamped_subtract(m_upload_mode_time, seconds);
 	}
@@ -12145,8 +12144,8 @@
 		st->added_time = m_added_time;
 		st->completed_time = m_completed_time;

-		st->last_scrape = m_last_scrape == (std::numeric_limits<boost::int16_t>::min)() ? -1
-			: clamped_subtract(m_ses.session_time(), m_last_scrape);
+		st->last_scrape = m_last_scrape == unset ? -1
+			: total_seconds(clock_type::now() - time_point(seconds(m_last_scrape)));

 		st->share_mode = m_share_mode;
 		st->upload_mode = m_upload_mode;
@@ -12168,10 +12167,10 @@
 		st->finished_time = finished_time();
 		st->active_time = active_time();
 		st->seeding_time = seeding_time();
-		st->time_since_upload = m_last_upload == (std::numeric_limits<boost::int16_t>::min)() ? -1
-			: clamped_subtract(m_ses.session_time(), m_last_upload);
-		st->time_since_download = m_last_download == (std::numeric_limits<boost::int16_t>::min)() ? -1
-			: clamped_subtract(m_ses.session_time(), m_last_download);
+		st->time_since_upload = m_last_upload == unset ? -1
+			: total_seconds(clock_type::now() - time_point(seconds(m_last_upload)));
+		st->time_since_download = m_last_download == unset ? -1
+			: total_seconds(clock_type::now() - time_point(seconds(m_last_download)));

 		st->storage_mode = static_cast<storage_mode_t>(m_storage_mode);

--- a/test/test_resume.cpp	2018-04-09 14:04:33.000000000 +0700
+++ b/test/test_resume.cpp	2018-04-25 10:16:54.000000000 +0700
@@ -99,9 +99,9 @@
 	rd["super_seeding"] = 0;
 	rd["added_time"] = 1347;
 	rd["completed_time"] = 1348;
-	rd["last_scrape"] = 1349;
-	rd["last_download"] = 1350;
-	rd["last_upload"] = 1351;
+	rd["last_scrape"] = 1;
+	rd["last_download"] = 2;
+	rd["last_upload"] = 3;
 	rd["finished_time"] = 1352;
 	if (file_priorities && file_priorities[0])
 	{
@@ -177,14 +177,15 @@
 	// allow some slack in the time stamps since they are reported as
 	// relative times. If the computer is busy while running the unit test
 	// or running under valgrind it may take several seconds
-	TEST_CHECK(s.last_scrape >= 1349);
-	TEST_CHECK(s.time_since_download >= 1350);
-	TEST_CHECK(s.time_since_upload >= 1351);
+	int const now = duration_cast<seconds>(clock_type::now().time_since_epoch()).count();
+	TEST_CHECK(s.last_scrape >= now - 1);
+	TEST_CHECK(s.time_since_download >= now - 2);
+	TEST_CHECK(s.time_since_upload >= now - 3);
 	TEST_CHECK(s.active_time >= 1339);

-	TEST_CHECK(s.last_scrape < 1349 + 10);
-	TEST_CHECK(s.time_since_download < 1350 + 10);
-	TEST_CHECK(s.time_since_upload < 1351 + 10);
+	TEST_CHECK(s.last_scrape < now - 1 + 10);
+	TEST_CHECK(s.time_since_download < now - 2 + 10);
+	TEST_CHECK(s.time_since_upload < now - 3 + 10);
 	TEST_CHECK(s.active_time < 1339 + 10);

 	TEST_CHECK(s.finished_time >= 1352);
--- a/test/test_storage.cpp	2018-04-09 14:04:33.000000000 +0700
+++ b/test/test_storage.cpp	2018-04-25 10:16:54.000000000 +0700
@@ -415,6 +415,18 @@
 	TEST_EQUAL(s->files().file_path(0), "new_filename");
 }

+struct test_error_storage : default_storage
+{
+	test_error_storage(storage_params const& params) : default_storage(params) {};
+
+	bool has_any_file(storage_error& ec) TORRENT_FINAL
+	{
+		ec.ec = make_error_code(boost::system::errc::permission_denied);
+		ec.operation = storage_error::stat;
+		return false;
+	}
+};
+
 void test_check_files(std::string const& test_path
 	, libtorrent::storage_mode_t storage_mode
 	, bool unbuffered)
@@ -458,22 +470,21 @@
 	bencode(std::back_inserter(buf), t.generate());
 	info = boost::make_shared<torrent_info>(&buf[0], buf.size(), boost::ref(ec), 0);

-	aux::session_settings set;
 	file_pool fp;
 	boost::asio::io_service ios;
 	counters cnt;
 	disk_io_thread io(ios, cnt, NULL);
 	io.set_num_threads(1);
-	disk_buffer_pool dp(16 * 1024, ios, boost::bind(&nop));
+	std::vector<uint8_t> prio(info->num_files(), 0);
 	storage_params p;
 	p.files = &fs;
 	p.path = test_path;
 	p.pool = &fp;
 	p.mode = storage_mode;
+	p.priorities = &prio;

 	boost::shared_ptr<void> dummy;
-	boost::shared_ptr<piece_manager> pm = boost::make_shared<piece_manager>(new default_storage(p), dummy, &fs);
-	libtorrent::mutex lock;
+	boost::shared_ptr<piece_manager> pm = boost::make_shared<piece_manager>(new test_error_storage(p), dummy, &fs);

 	bool done = false;
 	bdecode_node frd;
@@ -481,10 +492,18 @@
 	io.async_check_fastresume(pm.get(), &frd, links
 		, boost::bind(&on_check_resume_data, _1, &done));
 	io.submit_jobs();
-	ios.reset();
 	run_until(ios, done);

-	io.set_num_threads(0);
+	for (int i = 0; i < info->num_pieces(); ++i)
+	{
+		done = false;
+		io.async_hash(pm.get(), i, disk_io_job::sequential_access | disk_io_job::volatile_read
+			, boost::bind(&on_check_resume_data, _1, &done), reinterpret_cast<void*>(1));
+		io.submit_jobs();
+		run_until(ios, done);
+	}
+
+	io.abort(true);
 }

 // TODO: 2 split this test up into smaller parts
